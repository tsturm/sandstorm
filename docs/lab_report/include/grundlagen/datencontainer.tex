% !TEX root = ../../report.tex
\section{Die Datencontainer}
\begin{Spacing}{\mylinespace}
Um die Echtzeitfähigkeit unseres Systems zu gewährleisten, benötigt es GPU-Unterstützung.
Bevor wir jedoch in technische Details verfallen, werden wir einen kleinen Exkurs machen wie GPUs eigentlich funktionieren.
\subsection{Die GPU}
CPUs und GPUs weisen grundlegend verschiedene Architekturen auf.
\begin{figure}[h!]
	\vspace*{30px}
	\centering
	\includegraphics[width=300px]{graphics/GPUvsCPU.jpg}	
	\caption{GPU-Architektur\protect\footnotemark}
	\label{fig:GPUvsCPU}
\end{figure}
\footnotetext{Quelle: \url{http://www.tomshardware.de/CUDA-Nvidia-CPU-GPU,testberichte-240065-2.html}}
\\
Während eine CPU einen relativ großen Befehlssatz hat um Ganz- oder Fließkommazahlen zu verarbeiten, besitzt hingegen eine GPU einen sehr kleinen Befehlsatz und kann lediglich Fließkommazahlen verarbeiten.
Der große Vorteil einer GPU jedoch ist das sie die Möglichkeit besitzt Berechnungsaufgaben an verschiedene kleinere CO-Prozessoren sogenannte Shader-Units abzugeben.
Durch das zuweisen einer Aufgabe pro Shader-Unit erlaubt eine GPU somit das hoch-parallele abarbeiten von Aufgaben - solange diese unabhängig voneinander sind.
Diese parallele Programmierung hat jedoch auch Nachteile.
Nicht nur das es einer speziellen Programmierung benötigt - sogenannte Shader-Programmierung (Shader-Programme).
Sondern es setzt auch Vorraus, das jede Shader-Unit das gleiche Shader-Programm ausführt.
Besitzen jedoch die zu verarbeitenden Berechnungen genug Unabhänigkeit, so kann eine erhebliche Beschleunigung durch den Einsatz einer GPU welche meist hunderte von Shader-Units besitzt, erzielt werden.


\subsection{GPU-Programmierung}
GPUs und CPUs besitzen unabhängigen Speicher es benötigt somit nicht nur spezieller Programme, sondern auch den schwierigen Teil der GPU Programmierung - den Datentransport zwischen den Speichern.
Zur Vereinfachung nehmen wir in nachfolgenden Kapiteln an, das wir folgendes Viereck (s. Abbildung \ref{fig:Viereck}) zeichnen möchten.

\begin{figure}[h!]
	\vspace*{30px}
	\centering
	\includegraphics[height=130px]{graphics/Quad2.png}	
	\caption{Das Viereck}
	\label{fig:Viereck}
\end{figure}


\subsection{VertexBuffer}
Ein \textit{Vertex Buffer} ist ein Array, welches von dem CPU-Speicher in den GPU-Speicher übetragen wird.
Jeder Array Index bezieht sich dabei auf exakt einen Punkt im Raum.
Bezieht man sich auf unser Viereck aus Abbildung \ref{fig:Viereck} welches wir versuchen zu zeichnen bekommt man also folgendes Array: \\
\begin{figure}[h!]
	\vspace*{30px}
	\centering
	\includegraphics[height=150px]{graphics/vertexbuffer2.png}	
	\caption{Der VertexBuffer}
	\label{fig:VertexBuffer}
\end{figure}
\\
Überträgt man diesen \textit{Vertex Buffer} mittels eines Draw-Calls an die GPU so kann ein minimales Shader-Programm unser übergebenes Viereck zeichnen.

\subsection{IndexBuffer}
Wie man in Abbildung \ref{fig:VertexBuffer} erkennen kann, enthält der \textit{Vertex Buffer} duplizierte Einträge an den Stellen (0-4) und (2-5). Bei dem in unserem Beispiel verwendeten Viereck, fällt dieser unnötige Speicherverbrauch nicht großartig ins Gewicht. Bei weitaus komplexeren Modellen, können diese doppelten Einträge jedoch schnell zu einem Problem werden. Um doppelte Einräge im \textit{Vertex Buffer} zu verhindern, werden sogenannte \textit{Index Buffer} eingesetzt. Diese enthalten Indizes die auf die einzelnen Einträge im \textit{Vertex Buffer} referenzieren. Abbildung \ref{fig:IndexBuffer} zeigt, den für unser Beispiel benötigen, Index- und Vertex Buffer. Wie man sieht sind die doppelten Einträge aus unserem \textit{Vertex Buffer} verschwunden und die Reihenfolge zum Zeichen der beiden Dreiecke, wird nun durch den \textit{Index Buffer} vorgegeben. 
 

\begin{figure}[h!]
	\vspace*{30px}
	\centering
	\includegraphics[height=150px]{graphics/indexbuffer2.png}	
	\caption{Der IndexBuffer}
	\label{fig:IndexBuffer}
\end{figure}

\end{Spacing}
\clearpage
%% End Of Doc